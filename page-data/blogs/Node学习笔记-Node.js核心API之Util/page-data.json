{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/blogs/Node学习笔记-Node.js核心API之Util/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"06cd0f98-4a4e-5cdb-a745-8dd4bd3e9b95","html":"<p>最近正在学习Node，在图书馆借了基本关于Node的书，同时在网上查阅资料，颇有收获，但是整体感觉对Node的理解还是停留在一个很模棱两可的状态。比如Node中的模块，平时练习就接触到那么几个，其他的一些模块暂时只会在学习的时候接触到，不常用便就荒废了。正所谓好记心不如烂笔头，多做笔记还是更有利于理解和记忆。自己做的总结也方便回头复习，所以决定踏上漫长的修炼之旅……</p>\n<!--more-->\n<p>##util模块\r\nutil 是一个 Node.js 核心模块，提供了一些常用函数，用于弥补核心 JavaScript 的功能过于精简的不足。这些函数都包含在 <code>util</code> 模块中，可以通过引用模块来使用它们。</p>\n<p>###util.format(format, […])\r\n返回一个格式化的字符串，其作用效果有点类似 <code>printf</code>。第一个参数是一个包含若干个占位符的字符串。将每个参数转换后的值代替参数对应的占位符。支持占位符有：</p>\n<ul>\n<li>%s - String.</li>\n<li>%d - Number (both integer and float).</li>\n<li>%j - JSON.</li>\n<li>% - single percent sign (’%’). This does not consume an argument.</li>\n</ul>\n<p>如果第一个参数中的占位符找不到与之对应的参数， 那么这个占位符将不会被替换</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">util.format('%s:%s', 'foo'); // 'foo:%s'</code></pre></div>\n<p>如果占位符太少，多余的参数会调用 <code>util.inspect()</code> 转换成字符串，然后用空格将多余的字符串拼接在一起。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">util.format('%s:%s', 'foo', 'bar', 'baz', 'zhanglun'); // 'foo:bar baz zhanglun'</code></pre></div>\n<p>如果第一个参数不是一个需要格式化的字符串，那么这个方法会将所有的参数用空格拼接成一个新的字符串，然后返回这个字符串。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">util.format(1, 2, 3, \"zhanglun\"); // '1 2 3 \\'zhanglun\\''</code></pre></div>\n<p>###util.debug(string)\r\n这是一个同步输出的方法。当执行到这一句代码的时候会阻塞进程，并且以标准错误的形式将参数 string 输出。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require('util').debug('message on stderr'); //message on stderr</code></pre></div>\n<p>###util.log(string)\r\n以标准输出的形式输出。它将获取当前的时间戳，并和参数 string 一起输出，中间用 ” - ” 连接。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require('util').log('Timestmaped message.'); //15 May 21:41:33 - Timestmaped message</code></pre></div>\n<p>###util.inspect(object,[options])\r\n这个方法将任意对象转换为字符串，对调试来说很有用。至少接受一个参数 object，即需要处理的字符串。此外还可以传递一个可选的参数 options，用来控制字符串的输出格式。</p>\n<ul>\n<li><code>showHidden</code>——如果<code>showHidden</code>为 true，那么这个方法将会把参数 object 中不可枚举的属性输出。</li>\n<li><code>depth</code>——表示最大的递归层数。如果指定了 depth，也就指定了格式化代码时递归的次数。如果不指定depth，默认会递归2次，指定为 null 时将不限定次数，完整地遍历对象。</li>\n<li><code>color</code>——如果<code>color</code>为 true，输出的格式将会以 ANSI 颜色编码，可以在终端显示更漂亮的效果。</li>\n<li><code>customInspect</code>——如果为 false，那么将要被遍历检查的对象（参数object）中定义的<code>inspect（）</code>函数将不会被调用。 默认值为 true。</li>\n</ul>\n<p>下面先来看一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var util = require(\"util\");\r\nvar obj1 = {\r\n        \"aa\": function() {\r\n            console.log(\"aa\");\r\n        },\r\n        \"inspect\": function() {\r\n            console.log(\"obj1's inspect()\");\r\n        },\r\n        \"bb\": function() {\r\n            console.log(\"bb\");\r\n        }\r\n    },\r\n    obj2 = {\r\n        \"cc\": function() {\r\n            console.log(\"cc\");\r\n        },\r\n        \"inspect\": function() {\r\n            console.log(\"obj2's inspect()\");\r\n            return \"Hello\";\r\n        },\r\n        \"dd\": function() {\r\n            console.log(\"dd\");\r\n        }\r\n    };\r\n\r\nvar str1 = util.inspect(obj1, {\r\n    showHidden: false,\r\n    depth: null,\r\n    customInspect: false\r\n}),\r\n    str2 = util.inspect(obj2, {\r\n        showHidden: false,\r\n        depth: null,\r\n        customInspect: true\r\n    });\r\n\r\nconsole.log(\"str1 : \" + str1);\r\nconsole.log(\"str2 : \" + str2);</code></pre></div>\n<p>其输出结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">obj2's inspect()\r\nstr1 : { aa: [Function], inspacet: [Function], bb: [Function] }\r\nstr2 : Hello</code></pre></div>\n<p>暂时先忽略颜色，待会接着说，先看<code>customInspect</code>。上面的例子中，有两个对象：obj1 和 obj2，内部都定义了一个 inspect()函数，调用<code>util.inspect()</code>方法时，只有<code>customInspect</code>不同。当<code>customInspect</code>为 true 时，比如 obj2，其内部的 <code>util.inspect()</code>函数在执行<code>util.inspect()</code>时就被调用了，同时只会返回这个内部的 <code>util.inspect()</code>执行后的返回值，如果没有函数显示地调用 return 语句，则返回 undefined。可以试试修改上面的示例代码中 obj2 的<code>inspect()</code>的返回值。而对于 obj1，其<code>customInspect</code>，所以其内部的<code>inspect()</code>并不会被调用。</p>\n<p>####定制颜色\r\n可以通过两个对象：<code>util.inspect.styles</code>和<code>util.inspect.colors</code>全局定制输出的颜色。<code>util.inspect.styles</code>是一个<code>util.inspect.colors</code>中的颜色到样式的映射。后面的没搞懂怎么回事，以后再补上。</p>\n<p>###util.isArray(object)\r\n如果参数 object 是一个数组，返回 true，否则返回 false。\r\nvar util = require(‘util’);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">util.isArray([])\r\n  // true\r\nutil.isArray(new Array)\r\n  // true\r\nutil.isArray({})\r\n  // false\r\n  </code></pre></div>\n<p>###util.isRegExp(object)\r\n如果参数 object 是一个 RegExp 对象，返回 true，否则返回 false。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var util = require('util');\r\n\r\nutil.isRegExp(/some regexp/)\r\n  // true\r\nutil.isRegExp(new RegExp('another regexp'))\r\n  // true\r\nutil.isRegExp({})\r\n  // false\r\n  </code></pre></div>\n<p>###util.isDate(object)</p>\n<p>如果参数 object 是一个 Date 对象，返回 true，否则返回 false。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var util = require('util');\r\n\r\nutil.isDate(new Date())\r\n  // true\r\nutil.isDate(Date())\r\n  // false (without 'new' returns a String)\r\nutil.isDate({})\r\n  // false\r\n  </code></pre></div>\n<p>###util.isError(object)</p>\n<p>如果参数 object 是一个 Error 对象，返回 true，否则返回 false。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var util = require('util');\r\n\r\nutil.isError(new Error())\r\n  // true\r\nutil.isError(new TypeError())\r\n  // true\r\nutil.isError({ name: 'Error', message: 'an error occurred' })\r\n  // false\r\n  </code></pre></div>\n<p>###util.inherits(constructor, superConstructor)\r\n这是一个实现对象之间原型继承的函数。constructor 将会继承 superConstructor。另外，通过<code>constructor.super_</code>可以访问到 superConstructor。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var util = require(\"util\");\r\nvar events = require(\"events\");\r\n\r\nfunction MyStream() {\r\n}\r\nutil.inherits(MyStream, events.EventEmitter);\r\n\r\nMyStream.prototype.write = function(data) {\r\n    this.emit(\"data\", data);\r\n}\r\n\r\nvar stream = new MyStream();\r\n\r\n\r\nconsole.log(stream instanceof events.EventEmitter); // true\r\nconsole.log(MyStream.super_); \r\n//{ [Function: EventEmitter] listenerCount: [Function] }\r\nconsole.log(MyStream.super_ === events.EventEmitter); // true\r\n\r\nstream.on(\"data\", function(data) {\r\n    console.log('Received data: \"' + data + '\"');\r\n})\r\nstream.write(\"It works!\"); // Received data: \"It works!\"</code></pre></div>\n<p>util 模块还提供了其他的一些工具函数，更多详情请戳<a href=\"http://nodejs.org/api/util.html#util_util\">这里</a>。</p>","frontmatter":{"title":"Node学习笔记—Node.js核心API之Util","date":"May 15, 2014","description":null,"categories":["Node.js"],"tags":["笔记","Node.js"]}},"previous":{"fields":{"slug":"/blogs/(译)取消事件冒泡的危害/"},"frontmatter":{"title":"(译)阻止事件传播的危害"}},"next":{"fields":{"slug":"/blogs/Node学习笔记-Node.js核心API之HTTP/"},"frontmatter":{"title":"Node学习笔记-Node.js中的核心API之HTTP","draft":null,"tags":["笔记","Node.js"],"categories":["Node.js"],"status":"publish"}}},"pageContext":{"id":"06cd0f98-4a4e-5cdb-a745-8dd4bd3e9b95","previousPostId":"370c792e-099d-5e57-8328-93f05e976a63","nextPostId":"a91d13d7-220d-5be4-ada3-e10101f50f4b"}},
    "staticQueryHashes": ["2841359383"]}