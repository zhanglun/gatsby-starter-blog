{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/blogs/JavaScript中不使用new的构造函数/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"5d0cd4bc-6b61-5959-82c6-b4f12c8f00d9","html":"<p>在JavaScript 中，调用构造函数的方法很简单。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// 调用Point构造函数</span>\r\n<span class=\"token comment\">// 使用new 关键字</span>\r\n<span class=\"token keyword\">var</span> p1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token comment\">// 不使用new 关键字</span>\r\n<span class=\"token keyword\">var</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>但是，要知道: new关键词的使用与否，产生的效果是不一样的。输出p1和p2可以很清楚的看到，\r\np1指向的是一个对象，这个对象的构造函数是Point()，而p2返回的是<code class=\"language-text\">undefined</code>。仔细一想其实也很好理解。不带new关键字的调用，实质上与调用普通的方法函数无异，关键之处在于调用时，所处的作用域为全局作用域，this指向了window，也就是说，这次调用发生之后，平白无故的为window对象增添了两个属性x和y。</p>\n<p>为了解决这种问题，可以在构造函数中检查当前作用域，也就是this指向何处。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span>y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y\r\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样一来，即使在不使用new的情况下，构造函数也会自动使用new关键字。</p>\n<p>说到这，让我有了探究new 操作符和this相关的知识点！！！</p>\n<h3>JavaScript中的new</h3>\n<p>new操作符用来创建对象类型的一个实例，无论是用户自定义的对象类型还是内建对象类型，前提是得要有对象的构造函数。</p>\n<p>基本语法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">constructor</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>arguments<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">//可以看到调用时，构造函数后面的括号和参数都可选的</span></code></pre></div>\n<p>使用new创建一个用户自定义对象的实例是有以下两个步骤：</p>\n<ol>\n<li>编写构造函数，定义对象类型</li>\n<li>使用new操作符创建该对象的一个实例</li>\n</ol>\n<p>在自定义对象类型的时候，需要创建一个函数，指明对象的名字（也就是函数名）以及属性。要知道，一个对象的属性可以来自另外的一个对象。来看看下面的例子。</p>\n<p>当语句<code class=\"language-text\">new foo(...)</code>在执行的时候，会发生下面的事情：</p>\n<ol>\n<li>创建一个新的对象，继承自<code class=\"language-text\">foo.prototype</code>。</li>\n<li>foo的constructor被调用，如果有指定的参数就传入参数；同时<code class=\"language-text\">this</code>与新创建的对象绑定在一起。在没有指定参数的情况下，<code class=\"language-text\">new foo</code> 和<code class=\"language-text\">new foo()</code>是相等的。在Backbone的教程中经常看到不带括号的调用。</li>\n<li>新的对象通过contructor函数，作为整个表达式的结果返回。如果contructor函数没有明确指出返回特定的对象，那么返回在第一步中创建的对象。一般来说，constructor没有返回一个值，但是可以指定返回的值来覆盖原本的对象。</li>\n</ol>\n<p>###JavaScript中的this</p>\n<p>关于this，水平有限，只是稍微了解一点js中的this。在大多数情况，this的值由函数的地阿英方式决定。this在执行期间不能被复制，每次函数调用的时候this的值也有可能会不同。它可以是全局的，当前对象或者任意对象，完全取决函数的调用方式。</p>\n<h4>全局上下文</h4>\n<p>在全局上下文中，this指代的是全局对象。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>doucment <span class=\"token operator\">===</span> document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//true</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">===</span> window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// true</span>\r\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'window name'</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// window name </span></code></pre></div>\n<h4>函数上下文</h4>\n<p>在函数内部，this的值取决于函数是如何调用的。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> window<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 全局对象</span></code></pre></div>\n<p>fun()调用时并不能决定this的值，因为代码不在严格模式下，this的值总是一个对象且默认为全局对象。而在严格模式下，this 的值根据运行时的上下文决定，如果没有定义this将是undefined。</p>\n<p>我们常看到类似这样的代码，声明一个全局的对象作为命名空间将一些属性方法什么的都绑定到这个对象上，借此来减少全局变量。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\r\n  prop<span class=\"token operator\">:</span> <span class=\"token number\">37</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// logs 37</span></code></pre></div>\n<p>当函数以对象中的方法的当时调用时，它们的this由调用该函数的对象进行设置。所以在上面的代码中，当f以对象o的方法调用时，this指向的便是o对象。在何处或者如何定义函数完全不会影响到this的行为。因为this的值去决定于调用函数的对象，这意味下面这么做this的行为也是一致的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>prop<span class=\"token operator\">:</span> <span class=\"token number\">37</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token function\">independent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\no<span class=\"token punctuation\">.</span>f <span class=\"token operator\">=</span> independent<span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出37</span></code></pre></div>\n<p>类似的，this的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们以对象o中的b对象中的g方法来调用independent方法。在这次执行期间，函数中的this将指向o.b。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">o<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>g<span class=\"token operator\">:</span> independent<span class=\"token punctuation\">,</span> prop<span class=\"token operator\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">.</span><span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// logs 42</span></code></pre></div>\n<p>相同的概念在定义在原型链中的方法也是一致的。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，表现得好像是这个方法就存在于这个对象上一样。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\np<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\r\np<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 5</span></code></pre></div>\n<p>在这个例子中，对象p没有属于它自己的f属性，它的f属性继承自它的原型。但是这对于最终在o中找到f属性的查找过程来说没有关系；查找过程首先从p.f的引用开始，所以函数中的this指向p。也就是说，因为f是作为p的方法调用的，所以它的this指向了p。这是JavaScript的原型继承中的一个有趣的特性。</p>\n<h4>构造函数中的this</h4>\n<p>当一个函数被作为一个构造函数来使用（使用new关键字），它的this与即将被创建的新对象绑定。</p>\n<p>注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'zhanglun'</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// A {name: 'zhanglun'}</span>\r\n\r\n<span class=\"token comment\">// 手动设置返回一个1</span>\r\n<span class=\"token keyword\">function</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'zhanglun'</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// B {name: 'zhanglun'}</span>\r\n\r\n<span class=\"token keyword\">function</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'zhanglun'</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Object {}</span>\r\n</code></pre></div>\n<h4>call and apply</h4>\n<p>当一个函数的函数体中使用了this关键字时，通过所有函数都从Function对象的原型中继承的call()方法和apply()方法调用时，它的值可以绑定到一个指定的对象上。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c<span class=\"token punctuation\">,</span> d</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b <span class=\"token operator\">+</span> c <span class=\"token operator\">+</span> d<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>a<span class=\"token operator\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token function\">add</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 + 3 + 5 + 7 = 16</span>\r\n\r\n<span class=\"token function\">add</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 + 3 + 10 + 20 = 34</span></code></pre></div>","frontmatter":{"title":"JavaScript 中不使用 new 的构造函数（以及由此引发的联想）","date":"January 28, 2015","description":null,"categories":[],"tags":["笔记"]}},"previous":{"fields":{"slug":"/blogs/2015-11-22-CSS布局的未来：网格布局/"},"frontmatter":{"title":"CSS 布局的未来：网格布局"}},"next":{"fields":{"slug":"/blogs/规范之路-行高的工作原理/"},"frontmatter":{"title":"规范之路-line-height的工作原理","draft":null,"tags":["CSS","笔记"],"categories":[],"status":"publish"}}},"pageContext":{"id":"5d0cd4bc-6b61-5959-82c6-b4f12c8f00d9","previousPostId":"56f0ded7-0d14-5910-9e31-e9572aa83d95","nextPostId":"dd6e394e-c9ca-5421-9b4c-679196e7e5ad"}},
    "staticQueryHashes": ["2841359383"]}